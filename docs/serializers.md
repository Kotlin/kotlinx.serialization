<!--- TEST_NAME SerializersTest -->

# Serializers

This is the third chapter of the [Kotlin Serialization Guide](serialization-guide.md).
In this chapter we'll take a look at serializers in more detail and see how custom serializers can be written.

**Table of contents**

<!--- TOC -->

* [Introduction to serializers](#introduction-to-serializers)
  * [Plugin-generated serializer](#plugin-generated-serializer)
  * [Plugin-generated generic serializer](#plugin-generated-generic-serializer)
  * [Builtin primitive serializers](#builtin-primitive-serializers)
  * [Constructing collection serializers](#constructing-collection-serializers)
  * [Using top-level serializer function](#using-top-level-serializer-function)
* [Custom serializers](#custom-serializers)
  * [Primitive serializer](#primitive-serializer)
  * [Composite serializer via surrogate](#composite-serializer-via-surrogate)
  * [Hand-written composite serializer](#hand-written-composite-serializer)
  * [Sequential decoding protocol (experimental)](#sequential-decoding-protocol-experimental)
  * [Serializing 3rd party classes](#serializing-3rd-party-classes)
  * [Passing a serializer manually](#passing-a-serializer-manually)
  * [Specifying serializer on a property](#specifying-serializer-on-a-property)
  * [Specifying serializers for a file](#specifying-serializers-for-a-file)
  * [Custom serializers for a generic type](#custom-serializers-for-a-generic-type)
  * [Format-specific serializers](#format-specific-serializers)
* [Contextual serialization](#contextual-serialization)
  * [Serializers module](#serializers-module)
* [Deriving external serializer for another Kotlin class (experimental)](#deriving-external-serializer-for-another-kotlin-class-experimental)
  * [External serialization uses properties](#external-serialization-uses-properties)

<!--- END -->

## Introduction to serializers

Format, like JSON, controls the _encoding_ of an object into specific output bytes, but how the object is decomposed 
into its constituent properties is controlled by a _serializer_. So far, we've been using automatically-derived
serializers using the [`@Serializable`][Serializable] annotation as explained in 
the [Serializable classes](/docs/basic-serialization.md#serializable-classes) section or builtin serializers that were shown in 
the [Builtin classes](/docs/builtin-classes.md) section.

As a motivating example, let us take the following `Color` class with an integer value storing its `rgb` bytes.

<!--- INCLUDE
import kotlinx.serialization.*
import kotlinx.serialization.json.*
-->

```kotlin
@Serializable
class Color(val rgb: Int)

fun main() {
    val green = Color(0x00ff00)
    println(Json.encodeToString(green))
}  
```              

> You can get the full code [here](../guide/example/example-serializer-01.kt).

By default, this class serializes its `rgb` property into JSON.

```text
{"rgb":65280}
```     

<!--- TEST -->

### Plugin-generated serializer

Every class marked with the `@Serializable` annotation, like the `Color` class from the previous example,
gets an instance of the [KSerializer] interface automatically generated by the Kotlin serialization compiler plugin.
We can retrieve this instance using `.serializer()` function on the class's companion object.

We can examine its [descriptor][KSerializer.descriptor] property that describes the structure of 
the serialized class. We'll learn more details about it in the upcoming sections.

<!--- INCLUDE 
import kotlinx.serialization.*

@Serializable
@SerialName("Color")
class Color(val rgb: Int)
-->

```kotlin
fun main() {
    val colorSerializer: KSerializer<Color> = Color.serializer()
    println(colorSerializer.descriptor)
} 
```             

> You can get the full code [here](../guide/example/example-serializer-02.kt).

```text
Color(rgb: kotlin.Int)
```

<!--- TEST -->

This serializer is automatically retrieved and used by the Kotlin serialization framework when the `Color` class
serialized on the top-level or used as a property of other classes.

> You cannot define your own function `serializer()` on a companion object of a serializable class. 

### Plugin-generated generic serializer

For generic classes, like the `Box` class shown in the [Generic classes](basic-serialization.md#generic-classes) section,
the automatically generated `.serializer()` function accepts as many parameters as there are type-parameters in the 
corresponding class. These parameters are of type [KSerializer], so the actual type argument's serializer has 
to be provided when constructing an instance of a serializer for a generic class.

<!--- INCLUDE 
import kotlinx.serialization.*

@Serializable
@SerialName("Color")
class Color(val rgb: Int)
-->

```kotlin
@Serializable           
@SerialName("Box")
class Box<T>(val contents: T)    

fun main() {
    val boxedColorSerializer = Box.serializer(Color.serializer())
    println(boxedColorSerializer.descriptor)
} 
```      

> You can get the full code [here](../guide/example/example-serializer-03.kt).                                                     

As we can see, a serializer was instantiated to serialize a concrete `Box<Color>`.

```text 
Box(contents: Color)
```       

<!--- TEST -->

### Builtin primitive serializers

The serializers for the [primitive builtin classes](builtin-classes.md#primitives) can be retrieved
using `.serializer()` extensions. 

<!--- INCLUDE
import kotlinx.serialization.*
import kotlinx.serialization.builtins.*
-->

```kotlin 
fun main() {
    val intSerializer: KSerializer<Int> = Int.serializer()
    println(intSerializer.descriptor)
}
```

> You can get the full code [here](../guide/example/example-serializer-04.kt).   

<!--- TEST 
PrimitiveDescriptor(kotlin.Int)
--> 

### Constructing collection serializers

[Builtin collection serializers](builtin-classes.md#lists), when needed, must be explicitly constructed
using the corresponding functions [ListSerializer()], [SetSerializer()], [MapSerializer()], etc.
These classes are generic, so to instantiate their serializer we must provide the serializers for the
corresponding number of their type parameters.
For example, we can produce a serializer for a `List<String>` in the following way.

<!--- INCLUDE
import kotlinx.serialization.*
import kotlinx.serialization.builtins.*
-->

```kotlin 
fun main() {   
    val stringListSerializer: KSerializer<List<String>> = ListSerializer(String.serializer()) 
    println(stringListSerializer.descriptor)
}
```

> You can get the full code [here](../guide/example/example-serializer-05.kt).  

<!--- TEST 
kotlin.collections.ArrayList(PrimitiveDescriptor(kotlin.String))
--> 

### Using top-level serializer function

When in doubt, you can always use the top-level generic [`serializer<T>()`][kotlinx.serialization.serializer] 
function to retrieve a serializer for an arbitrary Kotlin type in your source-code.

<!--- INCLUDE
import kotlinx.serialization.*
-->

```kotlin 
@Serializable            
@SerialName("Color")
class Color(val rgb: Int)

fun main() {        
    val stringToColorMapSerializer: KSerializer<Map<String, Color>> = serializer()
    println(stringToColorMapSerializer.descriptor)
}
```

> You can get the full code [here](../guide/example/example-serializer-06.kt).  

<!--- TEST 
kotlin.collections.LinkedHashMap(PrimitiveDescriptor(kotlin.String), Color(rgb: kotlin.Int))
--> 

## Custom serializers

A plugin-generated serializer is convenient, but it may not do what we want to see in JSON 
for such a class as `Color`, so let's study alternatives.

### Primitive serializer

We want to serialize the `Color` class as a hex string with green color represented as `"00ff00"`.
To achieve this, we write an object that implements the [KSerializer] interface for the `Color` class.

<!--- INCLUDE .*-serializer-.*
import kotlinx.serialization.*
import kotlinx.serialization.json.*
import kotlinx.serialization.encoding.*
import kotlinx.serialization.descriptors.*
-->

```kotlin
object ColorAsStringSerializer : KSerializer<Color> {
    override val descriptor: SerialDescriptor = PrimitiveSerialDescriptor("Color", PrimitiveKind.STRING)

    override fun serialize(encoder: Encoder, value: Color) {
        val string = value.rgb.toString(16).padStart(6, '0')
        encoder.encodeString(string)
    }

    override fun deserialize(decoder: Decoder): Color {
        val string = decoder.decodeString()
        return Color(string.toInt(16))
    }
}
```

Serializer has three required pieces. 

* The [serialize][SerializationStrategy.serialize] function implements [SerializationStrategy].
  It receives an instance of [Encoder] and a value to serialize.
  It uses `encodeXxx` functions of `Encoder` to represent a value as a sequence of primitives. There is an 
  `encodeXxx` for each primitive type supported by serialization. 
  In our example, [encodeString][Encoder.encodeString] is used.
  
* The [deserialize][DeserializationStrategy.deserialize] function implements [DeserializationStrategy].
  It receives an instance of [Decoder] and returns a 
  deserialized value. It uses `decodeXxx` functions of `Decoder` that mirror the corresponding functions of `Encoder`.
  In our example, [decodeString][Decoder.decodeString] is used.
  
* The [descriptor][KSerializer.descriptor] property must faithfully explain what exactly `encodeXxx` and `decodeXxx` 
  functions do so that a format implementation knows in advance what encoding/decoding methods they call. 
  Some formats might also use it to generate a schema of the serialized data. For primitive serialization, 
  the [PrimitiveSerialDescriptor][PrimitiveSerialDescriptor()] function must be used with a unique name of the 
  type that is being serialized.
  [PrimitiveKind] describes the specific `encodeXxx`/`decodeXxx` method that is being used in the implementation.
  
> When the `descriptor` does not correspond to the encoding/decoding methods, then the behavior of the resulting code
> is unspecified and may arbitrary change in futures updates.        
  
The next step is to bind serializer to a class. This is done with the [`@Serializable`][Serializable]annotation by adding
the [`with`][Serializable.with] property value.

```kotlin
@Serializable(with = ColorAsStringSerializer::class)
class Color(val rgb: Int)
```  

Now we can serialize `Color` class as we did before.

```kotlin
fun main() {
    val green = Color(0x00ff00)
    println(Json.encodeToString(green))
}  
```              

> You can get the full code [here](../guide/example/example-serializer-07.kt).

We get serial representation as a hex string that we wanted.

```text
"00ff00"
```                        

<!--- TEST -->    

Deserialization is also straightforward, because we implemented `deserialize` method.

<!--- INCLUDE 
object ColorAsStringSerializer : KSerializer<Color> {
    override val descriptor: SerialDescriptor = PrimitiveSerialDescriptor("Color", PrimitiveKind.STRING)

    override fun serialize(encoder: Encoder, value: Color) {
        val string = value.rgb.toString(16).padStart(6, '0')
        encoder.encodeString(string)
    }

    override fun deserialize(decoder: Decoder): Color {
        val string = decoder.decodeString()
        return Color(string.toInt(16))
    }
}
-->

```kotlin
@Serializable(with = ColorAsStringSerializer::class)
class Color(val rgb: Int)

fun main() {
    val color = Json.decodeFromString<Color>("\"00ff00\"")
    println(color.rgb) // prints 65280 
}  
```     

> You can get the full code [here](../guide/example/example-serializer-08.kt).

<!--- TEST 
65280
-->

It also works if we serialize or deserialize a different class with `Color` properties.

<!--- INCLUDE 
object ColorAsStringSerializer : KSerializer<Color> {
    override val descriptor: SerialDescriptor = PrimitiveSerialDescriptor("Color", PrimitiveKind.STRING)

    override fun serialize(encoder: Encoder, value: Color) {
        val string = value.rgb.toString(16).padStart(6, '0')
        encoder.encodeString(string)
    }

    override fun deserialize(decoder: Decoder): Color {
        val string = decoder.decodeString()
        return Color(string.toInt(16))
    }
}
-->

```kotlin
@Serializable(with = ColorAsStringSerializer::class)
data class Color(val rgb: Int)

@Serializable 
data class Settings(val background: Color, val foreground: Color)

fun main() {
    val data = Settings(Color(0xffffff), Color(0))
    val string = Json.encodeToString(data)
    println(string)
    require(Json.decodeFromString<Settings>(string) == data)
}  
```     

> You can get the full code [here](../guide/example/example-serializer-09.kt).

Both `Color` properties are serialized as strings.

```text 
{"background":"ffffff","foreground":"000000"}
```

<!--- TEST -->

### Composite serializer via surrogate

Now our challenge is to get `Color` serialized so that it is represented in JSON as if it is a class 
with three properties: `r`, `g`, and `b`, so that JSON encodes it as an object. 
The easiest way to achieve it is to define a _surrogate_ class mimicking the serialized form of the `Color` that
we are going to use for its serialization. We also set [SerialName] of this surrogate class to `Color`, so
that if a format uses this name, the surrogate looks like it is a `Color` class.
The surrogate class can be `private` and can enforce all the constraints on the serial representation 
of the class in its `init` block.

```kotlin
@Serializable
@SerialName("Color")
private class ColorSurrogate(val r: Int, val g: Int, val b: Int) {
    init {     
        require(r in 0..255 && g in 0..255 && b in 0..255)
    }
}
```

> An example of where the class name is used is shown in 
> the [Custom subclass serial name](polymorphism.md#custom-subclass-serial-name) section in the chapter on polymorphism.
  
Now we can use a `ColorSurrogate.serializer()` function to retrieve a plugin-generated serializer for the
surrogate class.

An implementation of [KSerializer] for our original `Color` class is going to perform a conversion between
`Color` and `ColorSurrogate`, but delegate the actual serialization logic to the `ColorSurrogate.serializer()`
using [encodeSerializableValue][Encoder.encodeSerializableValue] and
[decodeSerializableValue][Decoder.decodeSerializableValue], fully reusing an automatically
generated [SerialDescriptor] for the surrogate.

```kotlin
object ColorSerializer : KSerializer<Color> {
    override val descriptor: SerialDescriptor = ColorSurrogate.serializer().descriptor

    override fun serialize(encoder: Encoder, value: Color) {
        val surrogate = ColorSurrogate((value.rgb shr 16) and 0xff, (value.rgb shr 8) and 0xff, value.rgb and 0xff)
        encoder.encodeSerializableValue(ColorSurrogate.serializer(), surrogate)
    }

    override fun deserialize(decoder: Decoder): Color {
        val surrogate = decoder.decodeSerializableValue(ColorSurrogate.serializer())
        return Color((surrogate.r shl 16) or (surrogate.g shl 8) or surrogate.b)
    }
}
```
 
Bind `ColorSerializer` serializer to a `Color` class.

```kotlin
@Serializable(with = ColorSerializer::class)
class Color(val rgb: Int)
```  

Now we can enjoy the result of serialization of the `Color` class.

<!--- INCLUDE
fun main() {
    val green = Color(0x00ff00)
    println(Json.encodeToString(green))
}
-->

> You can get the full code [here](../guide/example/example-serializer-10.kt).

```text
{"r":0,"g":255,"b":0}
```                        

<!--- TEST -->    

### Hand-written composite serializer

There are some cases where a surrogate solution does not fit. It can be due to performance reasons
of avoiding additional allocation or where a configurable/dynamic set of properties of
the resulting serial representation is required. In this case, we need to manually write a class
serializer that mimics the behaviour of a serializer that is generated for a class. 

```kotlin 
object ColorAsObjectSerializer : KSerializer<Color> {
```

Let's introduce it piece by piece. First, a descriptor is defined using [buildClassSerialDescriptor] builder.
The [element][ClassSerialDescriptorBuilder.element] function in the builder DSL automatically fetches serializers
for the corresponding fields by their type. The order of elements is important. They are indexed starting from zero.

```kotlin
    override val descriptor: SerialDescriptor =
        buildClassSerialDescriptor("Color") {
            element<Int>("r")
            element<Int>("g")
            element<Int>("b")
        }
```                                                                        

> The "element" is a generic term here. What is an element of a descriptor depends of its [SerialKind]. 
> Elements of a class descriptor are its properties, elements of a enum descriptor are its cases, etc.

Then we write the `serialize` function using [encodeStructure] DSL that provides access to 
the [CompositeEncoder] in its block. The difference between [Encoder] and [CompositeEncoder] is that the latter
has `encodeXxxElement` functions that correspond to `encodeXxx` functions of the former. They must be called
in the same order as in the descriptor. 

```kotlin
    override fun serialize(encoder: Encoder, value: Color) =
        encoder.encodeStructure(descriptor) {
            encodeIntElement(descriptor, 0, (value.rgb shr 16) and 0xff)
            encodeIntElement(descriptor, 1, (value.rgb shr 8) and 0xff)
            encodeIntElement(descriptor, 2, value.rgb and 0xff)
        }
```                                     

The most complex piece of code is the `deserialize` function. It shall support formats, like JSON, that 
can decode properties in an arbitrary order. It starts with the call to [decodeStructure] to 
get access to a [CompositeDecoder]. Inside of it, we write a loop that repeatedly calls 
[decodeElementIndex][CompositeDecoder.decodeElementIndex] to decode the index of the next element, decode the corresponding
element using [decodeIntElement][CompositeDecoder.decodeIntElement] in our example, and terminate a loop when
`CompositeDecoder.DECODE_DONE` is encountered.

```kotlin
    override fun deserialize(decoder: Decoder): Color =
        decoder.decodeStructure(descriptor) {
            var r = -1
            var g = -1
            var b = -1
            while(true) {
                when (val index = decodeElementIndex(descriptor)) {
                    0 -> r = decodeIntElement(descriptor, 0)
                    1 -> g = decodeIntElement(descriptor, 1)
                    2 -> b = decodeIntElement(descriptor, 2)
                    CompositeDecoder.DECODE_DONE -> break
                    else -> error("Unexpected index: $index")
                }
            }
            require(r in 0..255 && g in 0..255 && b in 0..255)
            Color((r shl 16) or (g shl 8) or b)
        }
```

<!--- INCLUDE
}
-->
  
Bind the resulting serializer to the `Color` class and test its serialization/deserialization.

```kotlin   
@Serializable(with = ColorAsObjectSerializer::class)
data class Color(val rgb: Int)

fun main() {
    val color = Color(0x00ff00)
    val string = Json.encodeToString(color) 
    println(string)
    require(Json.decodeFromString<Color>(string) == color)
}  
```              

> You can get the full code [here](../guide/example/example-serializer-11.kt).

As before, we got the `Color` class represented as a JSON object with three keys:

```text
{"r":0,"g":255,"b":0}
```                        

<!--- TEST -->    

### Sequential decoding protocol (experimental)

The implementation of the `deserialize` function from the previous section works with any format. However,
some formats either always store all the complex data in order or do it sometimes (for example, JSON always stores
collections in order). With these formats, the complex protocol of calling `decodeElementIndex` in the loop is 
not needed and a faster implementation can be used if the [CompositeDecoder.decodeSequentially] function returns `true`.
The plugin-generated serializers are actually conceptually similar to the below code.

<!--- INCLUDE
object ColorAsObjectSerializer : KSerializer<Color> {

    override val descriptor: SerialDescriptor =
        buildClassSerialDescriptor("Color") {
            element<Int>("r")
            element<Int>("g")
            element<Int>("b")
        }

    override fun serialize(encoder: Encoder, value: Color) =
        encoder.encodeStructure(descriptor) {
            encodeIntElement(descriptor, 0, (value.rgb shr 16) and 0xff)
            encodeIntElement(descriptor, 1, (value.rgb shr 8) and 0xff)
            encodeIntElement(descriptor, 2, value.rgb and 0xff)
        }
-->

```kotlin
    override fun deserialize(decoder: Decoder): Color =
        decoder.decodeStructure(descriptor) {
            var r = -1
            var g = -1
            var b = -1     
            if (decodeSequentially()) { // sequential decoding protocol
                r = decodeIntElement(descriptor, 0)           
                g = decodeIntElement(descriptor, 1)  
                b = decodeIntElement(descriptor, 2)
            } else while(true) {
                when (val index = decodeElementIndex(descriptor)) {
                    0 -> r = decodeIntElement(descriptor, 0)
                    1 -> g = decodeIntElement(descriptor, 1)
                    2 -> b = decodeIntElement(descriptor, 2)
                    CompositeDecoder.DECODE_DONE -> break
                    else -> error("Unexpected index: $index")
                }
            }
            require(r in 0..255 && g in 0..255 && b in 0..255)
            Color((r shl 16) or (g shl 8) or b)
        }
```

<!--- INCLUDE
}        

@Serializable(with = ColorAsObjectSerializer::class)
data class Color(val rgb: Int)

fun main() {
    val color = Color(0x00ff00)
    val string = Json.encodeToString(color) 
    println(string)
    require(Json.decodeFromString<Color>(string) == color)
}  
-->

> You can get the full code [here](../guide/example/example-serializer-12.kt).

<!--- TEST
{"r":0,"g":255,"b":0}
--> 

### Serializing 3rd party classes

Sometimes an application has to work with an external type that is not serializable. 
Let us use [java.util.Date] as an example. As before, we start by writing an implementation for [KSerializer]
for the class. Our goal is to get a `Date` serialized as the long number of milliseconds following the 
approach from the [Primitive serializer](#primitive-serializer) section.

> In the following sections any kind of `Date` serializer would work. For example, if we want `Date` to be serialized 
> as an object, we would use an approach from 
> the [Composite serializer via surrogate](#composite-serializer-via-surrogate) section.     
> See also [Deriving external serializer for another Kotlin class (experimental)](#deriving-external-serializer-for-another-kotlin-class-experimental)
> when you need to serialize a 3rd-party Kotlin class which could have been serializable, but is not. 
  
<!--- INCLUDE 
import java.util.Date
import java.text.SimpleDateFormat
-->
  
```kotlin
object DateAsLongSerializer : KSerializer<Date> {
    override val descriptor: SerialDescriptor = PrimitiveSerialDescriptor("Date", PrimitiveKind.LONG)
    override fun serialize(encoder: Encoder, value: Date) = encoder.encodeLong(value.time)
    override fun deserialize(decoder: Decoder): Date = Date(decoder.decodeLong())
}
```

We cannot bind the `DateAsLongSerializer` serializer to the `Date` class with the [`@Serializable`][Serializable] annotation, 
because we don't control the `Date` source code. There are several ways to work around that.

### Passing a serializer manually
 
All `encodeToXxx` and `decodeFromXxx` functions have an overload with the first serializer parameter. 
When a non-serializable class, like `Date`, is the top-level class being serialized we can use those.

```kotlin
fun main() {                                              
    val kotlin10ReleaseDate = SimpleDateFormat("yyyy-MM-ddX").parse("2016-02-15+00") 
    println(Json.encodeToString(DateAsLongSerializer, kotlin10ReleaseDate))    
}
``` 

> You can get the full code [here](../guide/example/example-serializer-13.kt).

```text
1455494400000
```     

<!--- TEST -->

### Specifying serializer on a property

When a property of a non-serializable class, like `Date`, is serialized as part of a serializable class we must supply
its serializer, or the code does not compile. This is accomplished using the [`@Serializable`][Serializable] annotation on a property.

<!--- INCLUDE 
import java.util.Date
import java.text.SimpleDateFormat
  
object DateAsLongSerializer : KSerializer<Date> {
    override val descriptor: SerialDescriptor = PrimitiveSerialDescriptor("Date", PrimitiveKind.LONG)
    override fun serialize(encoder: Encoder, value: Date) = encoder.encodeLong(value.time)
    override fun deserialize(decoder: Decoder): Date = Date(decoder.decodeLong())
}
-->

```kotlin
@Serializable          
class ProgrammingLanguage(
    val name: String,
    @Serializable(with = DateAsLongSerializer::class)
    val stableReleaseDate: Date
)

fun main() {
    val data = ProgrammingLanguage("Kotlin", SimpleDateFormat("yyyy-MM-ddX").parse("2016-02-15+00"))
    println(Json.encodeToString(data))
}
``` 

> You can get the full code [here](../guide/example/example-serializer-14.kt).

The `stableReleaseDate` property is serialized with the serialization strategy that we specified for it:

```text
{"name":"Kotlin","stableReleaseDate":1455494400000}
```    

<!--- TEST -->

### Specifying serializers for a file 

A serializer for a specific type, like `Date`, can be specified for a whole source code file with the file-level
[UseSerializers] annotation at the beginning of the file.

```kotlin
@file:UseSerializers(DateAsLongSerializer::class)
```      

<!--- PREFIX -->

<!--- INCLUDE
import java.util.Date
import java.text.SimpleDateFormat
  
object DateAsLongSerializer : KSerializer<Date> {
    override val descriptor: SerialDescriptor = PrimitiveSerialDescriptor("Date", PrimitiveKind.LONG)
    override fun serialize(encoder: Encoder, value: Date) = encoder.encodeLong(value.time)
    override fun deserialize(decoder: Decoder): Date = Date(decoder.decodeLong())
}
-->

Now a `Date` property can be used in a serializable class without additional annotations.

```kotlin
@Serializable          
class ProgrammingLanguage(val name: String, val stableReleaseDate: Date)

fun main() {
    val data = ProgrammingLanguage("Kotlin", SimpleDateFormat("yyyy-MM-ddX").parse("2016-02-15+00"))
    println(Json.encodeToString(data))
}
```   
> You can get the full code [here](../guide/example/example-serializer-15.kt).

```text
{"name":"Kotlin","stableReleaseDate":1455494400000}
```

<!--- TEST --> 

### Custom serializers for a generic type

Let us take a look at the following example of the generic `Box<T>` class.
It is marked with `@Serializable(with = BoxSerializer::class)` as we plan to have a custom serialization 
strategy for it.

```kotlin       
@Serializable(with = BoxSerializer::class)
data class Box<T>(val contents: T) 
```                      

An implementation of [KSerializer] for a regular type is written as an `object` as we saw in this chapter
in the examples for the `Color` type. A generic class serializer is instantiated with serializers
for its generic parameters as we saw in the [Plugin-generated generic serializer](#plugin-generated-generic-serializer) section.
A custom serializer for a generic class must be a `class` with a constructor that accepts as many [KSerializer]
parameters as the type has generic parameters. Let us write a `Box<T>` serializer that erases itself during
serialization, delegating everything to the underlying serializer of its `data` property.

```kotlin
class BoxSerializer<T>(private val dataSerializer: KSerializer<T>) : KSerializer<Box<T>> {
    override val descriptor: SerialDescriptor = dataSerializer.descriptor
    override fun serialize(encoder: Encoder, value: Box<T>) = dataSerializer.serialize(encoder, value.contents)
    override fun deserialize(decoder: Decoder) = Box(dataSerializer.deserialize(decoder))
}
```

Now we can serialize and deserialize `Box<Project>`.

```kotlin
@Serializable
data class Project(val name: String)

fun main() {
    val box = Box(Project("kotlinx.serialization"))
    val string = Json.encodeToString(box)
    println(string)
    println(Json.decodeFromString<Box<Project>>(string))
}
```

> You can get the full code [here](../guide/example/example-serializer-16.kt).

The resulting JSON looks like the `Project` class was serialized directly.

```text
{"name":"kotlinx.serialization"}
Box(contents=Project(name=kotlinx.serialization))
```     

<!--- TEST -->

### Format-specific serializers

The above custom serializers worked in the same way for every format. However, there might be format-specific
features that a serializer implementation would like to take advantage of. 

* The [Json transformations](json.md#json-transformations) section of the [Json](json.md) chapter provides examples
  of serializers that utilize JSON-specific features.
  
* A format implementation can have a format-specific representation for a type as explained
  in the [Format-specific types](formats.md#format-specific-types) section of
  the [Alternative and custom formats (experimental)](formats.md) chapter.  
  
This chapter proceeds to a generic approach of tweaking serialization strategy based on the context.   

## Contextual serialization

All the previous approaches to specifying the custom serialization strategies that we saw were _static_, 
fully defined at compile-time. The exception was the [Passing a serializer manually](#passing-a-serializer-manually)
approach, but it worked only on a top-level object that is being serialized. You might need to change the serialization
strategy of objects deep in the serialized object tree at run-time so that it is selected in a context-dependent way.
For example, you might want to represent `java.util.Date` in JSON format as an ISO 6801 string or as a long integer
depending on a version of a protocol you are serializing data for. This is called _contextual_ serialization and
is supported by a built-in [ContextualSerializer] class. Usually, we don't have to use this serializer class explicitly 
as there is the [Contextual] annotation providing a shortcut to 
the `@Serializable(with = ContextualSerializer::class)` annotation 
and the [UseContextualSerialization] annotation that can be used on a file-level just like 
the [UseSerializers] annotation. Let's see an example utilizing the former.
   
<!--- INCLUDE
import java.util.Date
import java.text.SimpleDateFormat
-->
 
```kotlin
@Serializable          
class ProgrammingLanguage(
    val name: String,
    @Contextual 
    val stableReleaseDate: Date
)
```

<!--- INCLUDE

fun main() {
    val data = ProgrammingLanguage("Kotlin", SimpleDateFormat("yyyy-MM-ddX").parse("2016-02-15+00"))
    println(Json.encodeToString(data))
}
-->    

To actually serialize this class we must provide the corresponding context when calling `encodeToXxx`/`decodeFromXxx`
functions. Without it we'll get "Serializer for class 'Date' is not found" exception.

> See [here](../guide/example/example-serializer-17.kt) for the example that produces exception.
 
<!--- TEST LINES_START 
Exception in thread "main" kotlinx.serialization.SerializationException: Serializer for class 'Date' is not found.
Mark the class as @Serializable or provide the serializer explicitly.
-->

<!--- INCLUDE
import kotlinx.serialization.modules.*
import java.util.Date
import java.text.SimpleDateFormat
  
object DateAsLongSerializer : KSerializer<Date> {
    override val descriptor: SerialDescriptor = PrimitiveSerialDescriptor("Date", PrimitiveKind.LONG)
    override fun serialize(encoder: Encoder, value: Date) = encoder.encodeLong(value.time)
    override fun deserialize(decoder: Decoder): Date = Date(decoder.decodeLong())
}

@Serializable          
class ProgrammingLanguage(
    val name: String,
    @Contextual 
    val stableReleaseDate: Date
)
-->

### Serializers module

To provide a context, we define a [SerializersModule] instance that describes which serializers shall be used 
at run-time to serialize which contextually-serializable classes. This is done using the 
[SerializersModule {}][SerializersModule()] builder function, which provides [SerializersModuleBuilder] DSL to 
register serializers. In the below example we use [contextual] function with the serializer. The corresponding
class this serializer is defined for is fetched automatically via the `reified` type parameter.  

```kotlin
private val module = SerializersModule { 
    contextual(DateAsLongSerializer)
}
``` 

Next we create an instance of [Json] format with this serializers module using
[Json {}][Json()] builder function and the [serializersModule][JsonBuilder.serializersModule] property. 

> Details on custom JSON configurations can be found in 
> the [JSON configuration](json.md#json-configuration) section. 

```kotlin           
val format = Json { serializersModule = module }
```

Now we can serialize our data with this `format`.

```kotlin
fun main() {
    val data = ProgrammingLanguage("Kotlin", SimpleDateFormat("yyyy-MM-ddX").parse("2016-02-15+00"))
    println(format.encodeToString(data))
}
```

> You can get the full code [here](../guide/example/example-serializer-18.kt).
```text
{"name":"Kotlin","stableReleaseDate":1455494400000}
```

<!--- TEST -->

> Additional details on serialization modules are given in 
> the [Merging library serializers modules](polymorphism.md#merging-library-serializers-modules) section of
> the [Polymorphism](polymorphism.md) chapter.

## Deriving external serializer for another Kotlin class (experimental)

If a 3rd-party class to be serialized is a Kotlin class with properties-only primary constructor, a kind of
class which could have been made `@Serializable`, then you can generate an _external_ serializer for it
using the [Serializer] annotation on an object with [`forClass`][Serializer.forClass] property. 

```kotlin         
// NOT @Serializable
class Project(val name: String, val language: String)
                           
@Serializer(forClass = Project::class)
object ProjectSerializer
```

You must all bind this serializer to a class using one of the approaches explained in this chapter. We'll
follow the [Passing a serializer manually](#passing-a-serializer-manually) way for this example.

```kotlin 
fun main() {
    val data = Project("kotlinx.serialization", "Kotlin")
    println(Json.encodeToString(ProjectSerializer, data))    
}
```          

> You can get the full code [here](../guide/example/example-serializer-19.kt).

This gets all the `Project` properties serialized:

```text
{"name":"kotlinx.serialization","language":"Kotlin"}
```     

<!--- TEST -->

### External serialization uses properties 

As we saw earlier, the regular `@Serializer` annotation creates a serializer so that 
[Backing fields are serialized](basic-serialization.md#backing-fields-are-serialized). _External_ serialization using 
`Serializer(forClass = ...)` has no access to backing fields and works differently. 
It serializes only _accessible_ properties that have setter or are a part of the primary constructor. 
The following example shows it.

```kotlin        
// NOT @Serializable, will use external serializer
class Project(
    // val in a primary constructor -- serialized
    val name: String
) {
    var stars: Int = 0 // property with getter & setter -- serialized
 
    val path: String // getter only -- not serialized
        get() = "kotlin/$name"                                         

    private var locked: Boolean = false // private, not accessible -- not serialized 
}              

@Serializer(forClass = Project::class)
object ProjectSerializer

fun main() {
    val data = Project("kotlinx.serialization").apply { stars = 9000 }
    println(Json.encodeToString(ProjectSerializer, data))
}
```             

> You can get the full code [here](../guide/example/example-serializer-20.kt).
  
The output is shown below.  
  
```text
{"name":"kotlinx.serialization","stars":9000}
```     

<!--- TEST -->

---

The next chapter covers [Polymorphism](polymorphism.md).

<!-- Java references -->
[java.util.Date]: https://docs.oracle.com/javase/8/docs/api/java/util/Date.html

<!--- MODULE /kotlinx-serialization -->
<!--- INDEX kotlinx.serialization -->
[Serializable]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization/-serializable/index.html
[KSerializer]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization/-k-serializer/index.html
[KSerializer.descriptor]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization/-k-serializer/descriptor.html
[kotlinx.serialization.serializer]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization/serializer.html
[SerializationStrategy.serialize]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization/-serialization-strategy/serialize.html
[SerializationStrategy]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization/-serialization-strategy/index.html
[DeserializationStrategy.deserialize]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization/-deserialization-strategy/deserialize.html
[DeserializationStrategy]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization/-deserialization-strategy/index.html
[Serializable.with]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization/-serializable/with.html
[SerialName]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization/-serial-name/index.html
[UseSerializers]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization/-use-serializers/index.html
[ContextualSerializer]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization/-contextual-serializer/index.html
[Contextual]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization/-contextual/index.html
[UseContextualSerialization]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization/-use-contextual-serialization/index.html
[Serializer]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization/-serializer/index.html
[Serializer.forClass]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization/-serializer/for-class.html
<!--- INDEX kotlinx.serialization.builtins -->
[ListSerializer()]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization.builtins/-list-serializer.html
[SetSerializer()]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization.builtins/-set-serializer.html
[MapSerializer()]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization.builtins/-map-serializer.html
<!--- INDEX kotlinx.serialization.json -->
[Json]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization.json/-json/index.html
[Json()]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization.json/-json.html
[JsonBuilder.serializersModule]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization.json/-json-builder/serializers-module.html
<!--- INDEX kotlinx.serialization.encoding -->
[Encoder]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization.encoding/-encoder/index.html
[Encoder.encodeString]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization.encoding/-encoder/encode-string.html
[Decoder]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization.encoding/-decoder/index.html
[Decoder.decodeString]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization.encoding/-decoder/decode-string.html
[Encoder.encodeSerializableValue]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization.encoding/-encoder/encode-serializable-value.html
[Decoder.decodeSerializableValue]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization.encoding/-decoder/decode-serializable-value.html
[encodeStructure]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization.encoding/encode-structure.html
[CompositeEncoder]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization.encoding/-composite-encoder/index.html
[decodeStructure]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization.encoding/decode-structure.html
[CompositeDecoder]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization.encoding/-composite-decoder/index.html
[CompositeDecoder.decodeElementIndex]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization.encoding/-composite-decoder/decode-element-index.html
[CompositeDecoder.decodeIntElement]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization.encoding/-composite-decoder/decode-int-element.html
[CompositeDecoder.decodeSequentially]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization.encoding/-composite-decoder/decode-sequentially.html
<!--- INDEX kotlinx.serialization.descriptors -->
[PrimitiveSerialDescriptor()]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization.descriptors/-primitive-serial-descriptor.html
[PrimitiveKind]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization.descriptors/-primitive-kind/index.html
[SerialDescriptor]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization.descriptors/-serial-descriptor/index.html
[buildClassSerialDescriptor]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization.descriptors/build-class-serial-descriptor.html
[ClassSerialDescriptorBuilder.element]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization.descriptors/-class-serial-descriptor-builder/element.html
[SerialKind]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization.descriptors/-serial-kind/index.html
<!--- INDEX kotlinx.serialization.modules -->
[SerializersModule]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization.modules/-serializers-module/index.html
[SerializersModule()]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization.modules/-serializers-module.html
[SerializersModuleBuilder]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization.modules/-serializers-module-builder/index.html
[contextual]: https://kotlin.github.io/kotlinx.serialization/kotlinx-serialization/kotlinx.serialization.modules/contextual.html
<!--- END -->

